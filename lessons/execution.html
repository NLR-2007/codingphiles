<h2>Java Execution Process</h2>

<p>
The Java Execution Process explains how a Java program runs
from source code to final output.
</p>

<p>
Java follows a two-step execution process:
<br>
✔ Compilation<br>
✔ Execution
</p>

<h2>Step 1: Writing Java Source Code</h2>

<p>
The programmer writes Java code using a text editor or IDE.
</p>

<p>
The file is saved with the extension:
<br>
<b>.java</b>
</p>

<p>
Example:
<br>
Hello.java
</p>

<h2>Step 2: Compilation Process</h2>

<p>
The Java compiler (<b>javac</b>) compiles the source code.
</p>

<p>
During compilation:
<br>
✔ Syntax errors are checked<br>
✔ Source code is converted into bytecode
</p>

<p>
The output file generated is:
<br>
<b>.class</b> file
</p>

<h2>What is Bytecode?</h2>

<p>
Bytecode is an intermediate code generated by the Java compiler.
</p>

<p>
Characteristics of bytecode:
<br>
✔ Platform-independent<br>
✔ Not machine-specific<br>
✔ Executed only by JVM
</p>

<h2>Step 3: Class Loader</h2>

<p>
The Class Loader loads the <b>.class</b> file into the JVM.
</p>

<p>
Functions of Class Loader:
<br>
✔ Loads class files into memory<br>
✔ Verifies bytecode for security<br>
✔ Prevents unauthorized code execution
</p>

<h2>Step 4: Bytecode Verification</h2>

<p>
Before execution, the JVM verifies the bytecode.
</p>

<p>
Bytecode verification ensures:
<br>
✔ No illegal memory access<br>
✔ No stack overflow<br>
✔ Code follows Java security rules
</p>

<p>
This step makes Java secure.
</p>

<h2>Step 5: Execution Engine</h2>

<p>
The Execution Engine is responsible for executing bytecode.
</p>

<p>
It consists of:
<br>
✔ Interpreter<br>
✔ JIT Compiler (Just-In-Time)<br>
✔ Garbage Collector
</p>

<h2>Interpreter</h2>

<p>
The Interpreter reads and executes bytecode line by line.
</p>

<p>
Advantages:
<br>
✔ Simple execution<br>
✔ No need for compilation to machine code first
</p>

<p>
Disadvantage:
<br>
✔ Slower execution speed
</p>

<h2>JIT Compiler</h2>

<p>
The Just-In-Time (JIT) Compiler improves performance.
</p>

<p>
It converts frequently used bytecode into machine code.
</p>

<p>
Advantages:
<br>
✔ Faster execution<br>
✔ Optimized performance
</p>

<h2>Garbage Collector</h2>

<p>
The Garbage Collector automatically manages memory.
</p>

<p>
Functions:
<br>
✔ Identifies unused objects<br>
✔ Frees heap memory<br>
✔ Prevents memory leaks
</p>

<h2>Step 6: Runtime Memory Areas</h2>

<p>
During execution, JVM uses different memory areas:
</p>

<p>
✔ Method Area – Stores class information<br>
✔ Heap Area – Stores objects<br>
✔ Stack Area – Stores method calls and local variables<br>
✔ PC Register – Stores current instruction address<br>
✔ Native Method Stack – Stores native method calls
</p>

<h2>Step 7: Native Method Interface (JNI)</h2>

<p>
If the Java program uses native code,
JNI allows communication with C or C++ libraries.
</p>

<p>
This is used for:
<br>
✔ Hardware-level access<br>
✔ Platform-specific operations
</p>

<h2>Final Output</h2>

<p>
After execution:
<br>
✔ Machine code runs on the operating system<br>
✔ Output is displayed to the user
</p>

<h2>Java Execution Flow Summary</h2>

<p>
Java Execution Flow:
<br>
✔ Source Code (.java)<br>
✔ Compilation (javac)<br>
✔ Bytecode (.class)<br>
✔ Class Loader<br>
✔ Bytecode Verifier<br>
✔ Execution Engine<br>
✔ Output
</p>

<h2>Why Java Execution is Platform Independent</h2>

<p>
Java programs run on any system because:
</p>

<p>
✔ Same bytecode is used everywhere<br>
✔ JVM handles OS differences<br>
✔ No need to recompile for different platforms
</p>

<h2>Java Execution Process (Exam Ready)</h2>

<p>
The Java execution process involves compiling source code into
bytecode, loading it into the JVM, verifying the code, executing it
using the interpreter and JIT compiler, and producing output through
the operating system.
</p>
